#!/usr/bin/env python3
#
# Version X1.92 Pre-Alpha release
#
# sdm-cportal implements a Captive Portal hotspot to obtain WiFi SSD and Password from the user
# test their validity, and subsequently configure wpa_supplicant.conf
#
# sdm-cportal is part of sdm, a tool that enables you to prepare IMGs that are fully customized
# By using sdm-cportal with an sdm-prepared IMG, the WiFi SSID and password are not bound until
# the system first boots.
#
# sdm-cportal can be used standalone, independently of sdm as well.
#
import argparse
import datetime
import importlib.util
import os
import shutil
import socket
import subprocess
import syslog
import threading
import time
from functools    import partial
from http.server  import HTTPServer
from http.server  import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

class htmsgs:
    def __init__(self):
        self.greeting_page = """
<html><body>
<h1>Captive Portal for host {}</h1>
<h2>Follow these steps to configure WiFi for host {}:</h2>
<ul>
<li>Click on the link below. A new browser page with a form will open</li>
<li>Fill out the form and click Submit</li>
<li>Wait until the ACT LED flashes "...." or 30-60 seconds 
<li>Ensure your device is connected to the Captive Portal WiFi Network via the Settings App</li>
<li>Click Check WiFi Connection Status</li>
<li><b>IMPORTANT:</b> The system configuration is not complete until you have a successful Configuration Results response</li>
</ul>
<h3><a href="http://{}/webform" target="_blank">Start WiFi Configuration</a></h3>
<br><br>
<ul>
<li>If needed, use the link below to check the connection status and complete the WiFi configuration</li>
<li>But first use the Settings App on your device to ensure you're connected to the Captive Portal WiFi Network again before clicking this link. <b>Turn WiFi Off/On, reconnect to the Captive Portal WiFi Network</b>
</ul>
<h3><a href="http://{}/checkresult" target="_blank">Check WiFi connection status</a></h3>
  </body></html>
"""

        self.web_form = """
 <html><body>
  <h1>WiFi Configuration for Host {}</h1>
<br>
<form action="/formsubmit">
    <table>
      <tr><td>SSID*</td><td><input type="text" name="ssid" value=""></td></tr>
      <tr><td>Password*</td><td><input type="text" name="password" value=""></td></tr>
      <tr><td>WiFi Country*</td><td><input type="text" name="wificountry" value=""></td></tr>
      <tr><td>Keymap</td><td><input type="text" name="keymap" value=""></td></tr>
      <tr><td>Locale</td><td><input type="text" name="locale" value=""></td></tr>
      <tr><td>Timezone</td><td><input type="text" name="timezone" value=""></td></tr>
      <tr><td>DHCPWait</td><td><input type="text" name="dhcpwait" value=""></td></tr>
    </table><p>
    <input type="submit" value="Submit">
  <div>
     <input type="checkbox" id="validate" checked name="validate">
    <label for="validate">Validate WiFi Configuration by Connecting</label>
  </div>
  <div>
     <input type="checkbox" id="ckinternet" checked name="ckinternet">
    <label for="ckinternet">Check Internet Connectivity after WiFi Connected</label>
  </div>
  <div>
     <input type="checkbox" id="wifipower" checked name="wifipower">
    <label for="wifipower">Enable WiFi Power Management</label>
  </div>
  </form>
*  Entry is Required
  </body></html>
"""

        self.testinprogress_page = """
<html><body>
<h3>Testing host {} WiFi Configuration...</h3>
<br>
<h3>Wait until the ACT LED flashes "...." or 30-60 seconds</h3>
<h3>Use the Settings app on your device to turn WiFi off/on...</h3>
<h3>...and then reconnect to the Captive Portal WiFi Network</h3>
<h3>Once connected, navigate to:</h3>
<h3><a href="http://{}/checkresult" target="_blank">Check WiFi connection status</a></h3>
</body></html>
"""

        self.wait_page = """
<html><body>
<h3>Still testing host {} WiFi Configuration...</h3>
<br>
<h3>Please continue waiting until the ACT LED flashes "...." or 30-60 seconds</h3>
<h3>Use the Settings app on your device to turn WiFi off/on...</h3>
<h3>...and then reconnect to the Captive Portal WiFi Network</h3>
<h3>Once connected, navigate to:</h3>
<h3><a href="http://{}/checkresult" target="_blank">Check WiFi connection status</a></h3>
</body></html>
"""
        self.notstarted_page = """
<html><body>
<h3>Host {} WiFi Configuration has not started</h3>
<br>
<h3>You must step through the Captive Portal in order</h3>
<h3>Please click this link to start the Captive Portal</h3>
<h3><a href="http://{}/" target="_blank">Start Captive Portal</a></h3>
</body></html>
"""
        self.notValidated = """
<html><body>
<h1>WiFi Configuration for host {} Complete</h1>
<h2>WiFi Connection was NOT Tested per request</h2>
</body></html>
"""

        self.giveup_page = """
<html><body>
<h3>Giving up on testing host {}</h3>
<br>
<h3>The Captive Portal will now exit</h3>
<h3>Consult your system provider for details on restarting the Captive Portal</h3>
</body></html>
"""
        # save this for a while
        self.fontsizes = """
      <font size = "1">Font size = "1"</font><br />
      <font size = "2">Font size = "2"</font><br />
      <font size = "3">Font size = "3"</font><br />
      <font size = "4">Font size = "4"</font><br />
      <font size = "5">Font size = "5"</font><br />
      <font size = "6">Font size = "6"</font><br />
      <font size = "7">Font size = "7"</font>
"""

def perrorexit(emsg):
    """
    Print the message and exit the program
    """
    raise SystemExit(emsg)

def qdelfile(fn):
    try:
        os.remove(fn)
    except OSError:
        pass

def qrename(src, dst):
    try:
        os.rename(src, dst)
    except OSError:
        pass

def qcopyfile(src, dst):
    """
    Copy src file to dst
    """
    try:
        shutil.copy(src, dst)
    except OSError:
        pass
    return

def nowtime():
    return datetime.datetime.strftime(datetime.datetime.now(), "%Y-%m-%d %H:%M:%S")  

def dosystem(docmd, timout=None):
    """
    Returns the result from subprocess.run, which contains stdout, returncode, etc.
    """
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True, timeout=int(timout) if type(timout) is int else None)
    return r

def syslogger(logstring):
    syslog.syslog(syslog.LOG_NOTICE, logstring)


def pxsyslogger(logstring):
    # syslog and then exit
    syslogger(logstring)
    perrorexit(logstring)

def tfcmd(docmd, nolog=False, msg=""):
    #
    # Returns return status from the command
    #
    if msg != "": syslogger(msg)
    if nolog is False: syslogger(f"Command: {docmd}")
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
    return r.returncode == 0
    
def gocmd(docmd):
    #
    # Returns stdout from the command
    #
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
    return r.stdout
    
def reportcmd(docmd, nolog=False, msg=""):
    #
    # syslog it unless nolog=True
    # If error status return print stderr
    #
    if msg != "": syslogger(msg)
    if nolog is False: syslogger(f"Command: {docmd}")
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
    if r.returncode != 0:
        print(f"{docmd}\n {r.stderr}")
    return r.returncode

def isrunning(sname):
    r = dosystem(f"systemctl --quiet is-active {sname}")
    return r.returncode == 0
    
def iponline(ipaddr, pingcount=1):
    return tfcmd(f"ping -c {pingcount} -W 2 {ipaddr}", nolog=True)

def waitapip(ipaddr):
    while not iponline(ipaddr):
        time.sleep(1)
    return

def read1stline(fn):
    try:
        with open(fn) as f: return f.readline().strip('\n')
    except:
        return ""

def getintval(inputval, switchname):
    retval = 0
    if not inputval is None:
        try:
            retval = int(inputval)
        except:
            pxsyslogger(f"? Invalid value '{inputval}' for {switchname}")
    return retval

class cpcontrol:
    def __init__(self):
        self.ledseq = { "APoff":"----", "APon":"-.--", "Testing":"--.-", "Results":"....", "Cleanup":"...-" }
        self.settings = { "ssid":"", "password":"", "wificountry":"US", "keymap":"", "locale":"", "timezone":"",\
                          "dhcpwait":"0", "validate":True, "ckinternet":True, "wifipower":"on" }
        self.errors = { "success":0, "noconnect":1, "nointernet":2, "manualgiveup":3, "notestdone":4 }
        self.sdm = self.stopflag = self.connected = self.iconnected = self.isresult = False
        self.formdone = self.inprogress = self.debug = False
        self.l10nhandler = self.defaults = self.allerrors = self.wlanip = self.apip = ""
        self.apssid = self.logmsg = self.facname = self.netns = self.apname = self.netdev = self.apdev = self.phydev = ""
        self.args = self.pdmsgs = None
        self.leds = self.netops = self.dhcp = self.atimer = None
        self.retries = 5
        self.timeout = 15
        self.status = 999
        self.hostname = socket.gethostname()
        self.sdndrunning = True if isrunning("systemd-networkd") == 0 else False

    def getwlanpm(self, devname):
        op = gocmd(f"iwconfig {devname}")
        for line in op.split('\n'):
            if "Power Management:" in line: return line.split(':')[1]
        return ""

    def writenetconfig(self):
        with open(f"/etc/systemd/network/{self.facname}-{self.apname}.network", 'w') as f:
            f.write(f"[Match]\n\
Name={self.apname}\n\
Type=wlan\n\
WLANInterfaceType=ap\n\
\n\
[Network]\n\
DHCPServer=yes\n\
LinkLocalAddressing=no\n\
Address={self.apip}/24\n\
ConfigureWithoutCarrier=yes\n\
IgnoreCarrierLoss=yes\n\
\n\
[DHCPServer]\n\
SendOption=114:string:https://{self.apip}/hotspot-detect.html\n\
DNS={self.apip}\n")

        with open(f"/etc/systemd/network/{self.facname}-{self.netdev}.network", 'w') as f:
            f.write(f"[Match]\n\
Name={self.netdev}\n\
\n\
[Network]\n\
DHCP=ipv4\n\
IPv6AcceptRA=false\n\
\n\
[DHCPv4]\n\
RouteMetric=20\n\
UseDomains=yes\n")

    def writewpaconf(self, wlan=""):
        wl = "" if wlan == "" else f"-{wlan}"
        with open(f"/etc/wpa_supplicant/wpa_supplicant{wl}.conf", 'w') as f:
            f.write(f"ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n\
country={self.settings['wificountry']}\n\
update_config=1\n\
\n\
network={{\n\
    ssid=\"{self.settings['ssid']}\"\n\
    psk=\"{self.settings['password']}\"\n\
    key_mgmt=WPA-PSK\n}}\n")

    def writeapwpaconf(self):
        ssid = f"{self.hostname}-{self.apssid}"
        with open(f"/etc/wpa_supplicant/wpa_supplicant-{self.apname}.conf", 'w') as f:
            f.write(f"ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n\
p2p_disabled=1\n\
country={self.settings['wificountry']}\n\
ap_scan=1\n\
\n\
network={{\n\
ssid=\"{ssid}\"\n\
mode=2\n\
key_mgmt=NONE\n}}\n")

    def writel10n(self, keymap, locale, timezone):
        ostr = ""
        if keymap != "": ostr = f"keymap={keymap}"
        if locale != "": ostr = f"{ostr}\nlocale={locale}"
        if timezone != "": ostr = f"{ostr}\ntimezone={timezone}"
        if ostr != "":
            if self.sdm:
                with open(f"/etc/{self.facname}/local-1piboot.conf", 'w') as f:
                    f.write(f"{ostr}\n")
            else:
                if self.l10nhandler != "":
                    reportcmd(f'{self.l10nhandler} "{keymap}" "{locale}" "{timezone}"', msg=f"Call L10N handler {self.l10nhandler}")

class DHCPClient():
    def __init__(self, pd):
        self.pd = pd
        self.dhcpclient = ""
        self.dhcpcdrunning = False
        self.nmrunning = False
        if isrunning("dhcpcd"):
            self.dhcpcdrunning = True
            self.dhcpclient = "dhcpcd"
        if isrunning("NetworkManager"):
            self.nmrunning = True
            self.dhcpclient = "NetworkManager"
        if self.dhcpclient == "":
            syslogger("No known running DHCP client found")
            self.dhcpclient = "dhcpcd"
        return

    def stopclient(self):
        reportcmd(f"systemctl stop {self.dhcpclient}", msg=f"Stop {self.dhcpclient}")

    def restartclient(self):
        if self.dhcpcdrunning or self.nmrunning:
            reportcmd(f"systemctl start {self.dhcpclient}", msg=f"Start {self.dhcpclient}")

class LEDflash(threading.Thread):
    def __init__(self, pd):
        threading.Thread.__init__(self)
        self.dit = 0.2
        self.dot = 0.5
        self.interval = 0.3
        self.pd = pd
        self.sequence = ""
        self.running = True
        self.actled = open("/sys/class/leds/ACT/brightness", 'w')

    def __del__(self):
        syslogger("LEDflash object deleted")

    def writeflush(self, ch):
        if not self.running: return
        self.actled.write(ch)
        self.actled.flush()

    def flashled(self, ch, ontime):
        if not self.running: return
        self.writeflush("1")
        time.sleep(ontime)
        self.writeflush("0")

    def setsequence(self, newsequence):
        self.sequence = newsequence
        syslogger(f'Set LED flash sequence: "{newsequence}"')
        return

    def setstopled(self):
        self.running = False
        self.sequence = ""
        self.writeflush("0")
        self.actled.close()

    def run(self):
        while self.running:
            flashthis = self.sequence
            if flashthis != "":
                for i in range(0, len(flashthis)):
                    ch = flashthis[i]
                    ontime = self.dit if ch == "." else self.dot
                    if self.running:
                        self.flashled(ch, ontime)
                    else:
                        break
                    if self.running: time.sleep(self.interval)
            if self.running: time.sleep(0.5)
        return

class Netops(threading.Thread):
    def __init__(self, pd):
        threading.Thread.__init__(self)
        self.pd = pd

    def __del__(self):
        syslogger("Netops object deleted")

    def run(self):
        if self.pd.inprogress:
            syslogger(f"Test Inputs already in progress")
            return
        self.pd.isresult = False
        self.pd.inprogress = True
        syslogger(f"Write wpa_supplicant-{self.pd.netdev}.conf")
        self.pd.leds.setsequence(self.pd.ledseq['Testing'])
        self.pd.writewpaconf(f"{self.pd.netdev}")
        # try this again someday
        #if "OK" in gocmd(f"wpa_cli -i {self.pd.netdev} reconfigure"):
            #syslogger(f"Successfully reconfigured {self.pd.netdev} wpa_supplicant")
        #else:
        reportcmd(f"systemctl restart wpa_supplicant@{self.pd.netdev}", msg=f"Restart wpa_supplicant@{self.pd.netdev} to use new SSID/password")
        # Wait for the network to come online
        myipaddr = ""
        for i in range(1, self.pd.settings['dhcpwait']):
            s = gocmd(f"ip -br -o -f inet addr show dev {self.pd.netdev}") 
            if s != "": myipaddr = ' '.join(s.split()).split(' ')[2].split('/')[0]
            if myipaddr != "" and not myipaddr.startswith("169.254"): break
            syslogger(f"Waiting ({i} of {self.pd.settings['dhcpwait']}) for {self.pd.netdev} to obtain an IP address")
            time.sleep(1)
        self.pd.wlanip = myipaddr
        if self.pd.wlanip != "":
            syslogger(f"Got IP address {self.pd.wlanip}")
            if self.pd.settings['ckinternet']  == "on" and self.pd.wlanip != "":
                syslogger("Test Internet accessibility")
                if iponline("1.1.1.1", pingcount=5):
                    syslogger("Internet is Accessible")
                    self.pd.iconnected = True
                else:
                    syslogger("Internet is Not Accessible")
        else:
            syslogger(f"Did not obtain an IP address")
        self.pd.isresult = True
        self.pd.leds.setsequence(self.pd.ledseq['Results'])
        return

class sdmRequestHandler(BaseHTTPRequestHandler):
    def __init__(self, pd, *args, **kwargs):
        self.pd = pd
        super().__init__(*args, **kwargs)

    def _set_response(self, rcode=200):
        self.send_response(rcode)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        return
        
    def log_message(self, *args, **kwargs):
        # Prevents debug output from going to stderr 
        return

    def _adderror(self, oldstring, newstring):
        syslogger(f"Error: {newstring}")
        if oldstring == "":
            return newstring
        return  f"{oldstring}<br>{newstring}"

    def _buildresponse(self, pd, redolink=False):
        response = f"<html><body><h1>WiFi Configuration Results for host {pd.hostname}</h1>"
        if self.pd.connected:
            response = f"{response}<h2>Obtained IP Address {self.pd.wlanip} via WiFi SSID '{self.pd.settings['ssid']}'<br></h2>"
        else:
            response = f"{response}<h2>WiFi Did NOT Connect Successfully</h2>"
        if self.pd.iconnected:
            response = f"{response}<h2>Internet IS Accessible</h2>"
        else:
            if not self.pd.settings['ckinternet'] == "on":
                response = f"{response}<h2>Internet Accessibility was not tested</h2>"
            else:
                response = f"{response}<h2>Internet is NOT Accessible</h2>"
        if redolink:
            response = f"{response}<h2><a href=\"http://{self.pd.apip}/\" target=\"_blank\">Restart Captive Portal</a></h2>"
            response = f"{response}<h2><a href=\"http://{self.pd.apip}/giveup\" target=\"_blank\">Cancel Captive Portal</a></h2>"
        return f"{response}</body></html>"

    def _write_response(self, htmltext):
        self._set_response()
        return self.wfile.write(htmltext.encode('utf-8'))
    
    def _setstop(self, pd):
        pd.writel10n(self.pd.settings['keymap'], self.pd.settings['locale'], self.pd.settings['timezone'])
        self.pd.stopflag = True

    def _notriesleft(self, status):
        self.pd.status = status
        self.pd.retries -= 1
        if self.pd.retries == 0:
            return True
        return False

    def do_GET(self):
        if not 'favicon' in self.path:
            syslogger(f"Received message {self.path}")
        if "/formsubmit" in self.path:
            query_items = parse_qs(urlparse(self.path).query, keep_blank_values=True)
            for i in self.pd.settings:
                if i in query_items: self.pd.settings[i] = query_items[i][0].strip()
            if self.pd.defaults != "":
                default_items = parse_qs(urlparse(pd.defaults).query, keep_blank_values=True)
                for i in self.pd.settings:
                    if i in default_items:
                        if default_items[i][0] != "":
                            self.pd.settings[i] = default_items[i][0].strip()
            self.pd.settings['wificountry'] = self.pd.settings['wificountry'].upper()
            self.pd.settings['keymap'] = self.pd.settings['keymap'].lower()

            # Validate inputs
            syslogger("Validate form data")
            self.pd.allerrors = ""
            if self.pd.settings['ssid'] == "":
                self.pd.allerrors = self._adderror(self.pd.allerrors, "SSID cannot be blank")
            if self.pd.settings['password'] == "":
                self.pd.allerrors = self._adderror(self.pd.allerrors, "Password cannot be blank")
            if self.pd.settings['keymap'] != "":
                if not tfcmd(f"grep \"^  {self.pd.settings['keymap']} \" /usr/share/doc/keyboard-configuration/xorg.lst", nolog=True):
                    self.pd.allerrors = self._adderror(self.pd.allerrors, f"Unrecognized keymap '{self.pd.settings['keymap']}'")
            if self.pd.settings['locale'] != "":
                if not tfcmd(f"grep \"^{self.pd.settings['locale']}\" /usr/share/i18n/SUPPORTED", nolog=True):
                    self.pd.allerrors = self._adderror(self.pd.allerrors, f"Unrecognized locale '{self.pd.settings['locale']}'")
            if self.pd.settings['wificountry'] != "":
                self.pd.settings['wificountry'] = self.pd.settings['wificountry'].upper()
                if not tfcmd(f"grep \"^{self.pd.settings['wificountry']}\" /usr/share/zoneinfo/iso3166.tab", nolog=True):
                    self.pd.allerrors = self._adderror(self.pd.allerrors, f"Unrecognized WiFi Country '{self.pd.settings['wificountry']}'")
            if self.pd.settings['timezone'] != "":
                if not os.path.isfile(f"/usr/share/zoneinfo/{self.pd.settings['timezone']}"):
                    self.pd.allerrors = self._adderror(self.pd.allerrors, f"Unrecognized Timezone '{self.pd.settings['timezone']}'")
            if self.pd.settings['dhcpwait'] != "":
                try:
                    dwait = self.pd.settings['dhcpwait']
                    self.pd.settings['dhcpwait'] = int(dwait)
                except:
                    self.pd.allerrors = self._adderror(self.pd.allerrors, f"dhcpwait value '{dwait}' is not numeric")
                    self.pd.settings['dhcpwait'] = 60
            else:
                self.pd.settings['dhcpwait'] = 60
            if self.pd.allerrors != "":
                syslogger("Errors were found")
                self.pd.allerrors = f"<html><body><h1>Errors Found for host {self.pd.hostname}</h1><h2>{self.pd.allerrors}</h2></body></html>"
                syslogger("Send error report message")
                self._write_response(self.pd.allerrors)
            else:
                self.pd.formdone = True
                syslogger("Form input validation complete")
                if self.pd.settings['validate'] == "on":
                    curpm = self.pd.getwlanpm(self.pd.netdev)
                    if self.pd.settings['wifipower'] == "on" and curpm != "on":
                        reportcmd(f"iwconfig {self.pd.netdev} power on", msg=f"Set {self.pd.netdev} Power Management on")
                    else:
                        if self.pd.settings['wifipower'] == "off" and curpm == "on":
                            reportcmd(f"iwconfig {self.pd.netdev} power off", msg=f"Set {self.pd.netdev} Power Management off")
                    syslogger("Start Validate WiFi configuration thread")
                    self.pd.netops = None         # Delete any previous instantiation
                    self.pd.netops = Netops(pd)
                    self.pd.netops.start()
                    syslogger("Send redirect to testinprogress")
                    self.send_response(302)
                    self.send_header('Location', f"http://{self.pd.apip}/testinprogress")
                    self.end_headers()
                else:
                    syslogger("Write WiFi configuration with No Validation")
                    self.pd.writewpaconf()
                    syslogger("Send notValidated message")
                    self._write_response(self.pd.pdmsgs.notValidated.format(self.pd.hostname))
                    self._notriesleft(self.pd.errors['notestdone'])
                    self._setstop(self.pd)
                    return
        elif self.path == "/" or "/hotspot-detect.html" in self.path:
            syslogger(f"Send greeting page to remote from query to {self.path}")
            self._write_response(self.pd.pdmsgs.greeting_page.format(self.pd.hostname, self.pd.hostname, self.pd.apip, self.pd.apip))
        elif self.path == "/testinprogress":
            syslogger("Send testinprogress page")
            self._write_response(self.pd.pdmsgs.testinprogress_page.format(self.pd.hostname, self.pd.apip))
        elif self.path == "/giveup":
            syslogger("Received manual 'give up' message")
            self.pd.status = self.pd.errors['manualgiveup']
            self._write_response(self.pd.pdmsgs.giveup_page.format(self.pd.hostname))
            self._setstop(pd)
        elif self.path == "/webform":
            syslogger("Send form page to remote")
            self._write_response(self.pd.pdmsgs.web_form.format(self.pd.hostname))
        elif self.path == "/checkresult":
            if not self.pd.formdone:
                syslogger("Checkresult called before form done")
                self._write_response(self.pd.notstarted_page(self.pd.hostname, self.pd.apip))
                return
            if not self.pd.isresult:
                syslogger("Checkresult called before result ready")
                self._write_response(self.pd.pdmsgs.wait_page.format(self.pd.hostname, self.pd.apip))
                return
            # get my ip address and error if it didn't connect
            myipaddr = self.pd.wlanip
            if myipaddr == "" or myipaddr.startswith("169.254"):
                syslogger("Failed to obtain an IP Address")
                syslogger("Send built response message")
                self._write_response(self._buildresponse(pd, redolink=True))
                self.pd.inprogress = False
                if self._notriesleft(self.pd.errors['noconnect']):
                    self._setstop(pd)
                return
            else:
                syslogger(f"Obtained IP Address {myipaddr}")
                self.pd.connected = True
                self.pd.wlanip = myipaddr
            if self.pd.settings['ckinternet'] == "on":
                if self.pd.iconnected:
                    syslogger("Internet is Accessible")
                    syslogger("Send built response message")
                    self._write_response(self._buildresponse(pd))
                    self.pd.status = self.pd.errors['success']
                    self.pd.inprogress = False
                    self._setstop(pd)
                else:
                    syslogger("Internet is Not Accessible")
                    syslogger("Send built response message")
                    self._write_response(self._buildresponse(pd))
                    self.pd.inprogress = False
                    self.pd.leds.setsequence(self.pd.ledseq['APon'])
                    if self._notriesleft(self.pd.errors['nointernet']):
                        self._setstop(pd)
            else:
                syslogger("WiFi Operational, no Internet check done")
                syslogger("Send built response message")
                self.pd.status = self.pd.errors['notestdone']
                self._write_response(self._buildresponse(self.pd))
                self.pd.inprogress = False
                self._notriesleft(self.pd.errors['notestdone'])
                self._setstop(pd)
        return

def docleanup(pd, resetcmd=False):
    if gocmd(f"iw dev {pd.apname} info") != "":
        if f"tmp-{pd.facname}" in gocmd(f"ip netns"):
            tfcmd(f"iw {pd.phydev} set netns name {pd.netns}", msg=f"Delete Access Point {pd.apname}")
            tfcmd(f"ip netns exec {pd.netns} iw dev {pd.apname} del")
            tfcmd(f"ip netns exec {pd.netns} iw {pd.phydev} set netns 1") # Set back to primary namespace
    tfcmd(f"iw dev {pd.apname} del")                         # Just in case
    tfcmd(f"ip netns del {pd.netns}")                                         # And delete temp ns, no longer needed
    tfcmd(f"systemctl stop wpa_supplicant@{pd.apname}", msg=f"Stop {pd.apname} wpa_supplicant")
    tfcmd(f"systemctl stop wpa_supplicant@{pd.netdev}", msg=f"Stop {pd.netdev} wpa_supplicant")
    qdelfile(f"/var/run/wpa_supplicant/{pd.apname}")
    qdelfile(f"/etc/systemd/network/{pd.facname}-{pd.apname}.network")
    qdelfile(f"/etc/systemd/network/{pd.facname}-{pd.netdev}.network")
    qdelfile(f"/etc/wpa_supplicant/wpa_supplicant-{pd.apname}.conf")
    qdelfile("/etc/wpa_supplicant/wpa_supplicant.conf")
    if not resetcmd:
            qrename(f"/etc/wpa_supplicant/wpa_supplicant-{pd.netdev}.conf", "/etc/wpa_supplicant/wpa_supplicant.conf")
    qdelfile(f"/etc/wpa_supplicant/wpa_supplicant-{pd.netdev}.conf")
    syslogger(f"Reload systemd and restart systemd-networkd and restart {pd.dhcp.dhcpclient}")
    if pd.sdndrunning:
        reportcmd("systemctl daemon-reload")
        reportcmd("systemctl restart systemd-networkd")
    else:
        reportcmd("systemctl stop systemd-networkd.socket")
        reportcmd("systemctl stop systemd-networkd")
        reportcmd("systemctl daemon-reload")
    #Toggle the netdev network. Seems to work better. Or maybe not. Keep the code, commented out, for now
    #reportcmd(f"networkctl down {pd.netdev}", msg=f"Toggle {pd.netdev} offline/online before {pd.dhcp.dhcpclient} restart")
    #reportcmd(f"networkctl up {pd.netdev}")
    pd.dhcp.restartclient()

def resetnet(pd):
    syslogger("Reset Captive Portal WiFi Network")
    docleanup(pd, resetcmd=True)
    syslogger("Captive Portal WiFi Network Reset Complete")
    
def runserver(pd):
    syslogger("Portal network reconfiguration")
    pd.dhcp.stopclient()
    reportcmd(f"systemctl stop systemd-networkd.socket", msg="Stop systemd-networkd")
    reportcmd(f"systemctl stop systemd-networkd")
    reportcmd(f"ip netns add {pd.netns}", msg="Reconfigure network to create Access Point")
    reportcmd(f"iw {pd.phydev} set netns name {pd.netns}")
    reportcmd(f"ip netns exec {pd.netns} iw phy {pd.phydev} interface add {pd.apname} type __ap")
    syslogger(f"Write /etc/systemd/network/{pd.facname}-{pd.apname}.network and /etc/systemd/network/{pd.facname}-{pd.netdev}.network")
    pd.writenetconfig()
    syslogger(f"Write /etc/wpa_supplicant/wpa_supplicant-{pd.apname}.conf")
    pd.settings['ssid'] = "foobarfoobar"
    pd.settings['password'] = "barfoobarfoobarfoobarfoo"
    pd.writewpaconf(wlan=pd.netdev)
    pd.writeapwpaconf()
    reportcmd(f"ip netns exec {pd.netns} iw {pd.phydev} set netns 1") # Set back to primary namespace
    qdelfile(f"/var/run/wpa_supplicant/{pd.apname}")
    reportcmd(f"systemctl daemon-reload", msg='Do daemon-reload and start systemd-networkd')
    reportcmd("systemctl start systemd-networkd")
    #reportcmd(f"systemctl start wpa_supplicant@{pd.netdev}", msg=f"Start wpa_supplicant@{pd.netdev}")
    reportcmd(f"systemctl start wpa_supplicant@{pd.apname}", msg=f"Start wpa_supplicant@{pd.apname}")
    syslogger("Wait for access point IP to come online")
    waitapip(pd.apip)
    server_address = (pd.apip, 80)
    pd.leds.setsequence(pd.ledseq['APon'])
    syslogger("Start HTTP Server")
    handler = partial(sdmRequestHandler, pd)
    httpd = HTTPServer(server_address, handler)
    while not pd.stopflag and pd.retries > 0:
        httpd.handle_request()
    httpd.server_close()
    syslogger("Reset Captive Portal WiFi Network")
    pd.leds.setsequence(pd.ledseq['Cleanup'])
    docleanup(pd)
    pd.leds.setstopled()
    pd.leds.writeflush("0")
    pd.leds = pd.netops = None
    syslogger("Captive Portal Complete")
    return pd.status

if __name__ == "__main__":
    pd = cpcontrol()
    parser = argparse.ArgumentParser(prog='cportal')
    parser.add_argument('--apssid', help="SSID name for Access Point")
    parser.add_argument('--apip', help="IP Address to use for Access Point")
    parser.add_argument('--country', default="US", help="Default WiFi country if user doesn't specify")
    parser.add_argument('--defaults', help="Provide a file with default settings")
    parser.add_argument('--reset', help="Reset networking configuration to non-portal state", action='store_true')
    #parser.add_argument('--debug', help="Print logged messages on console also", action='store_true')
    parser.add_argument('--facility', help="Facility name to use instead of 'sdm'")
    parser.add_argument('--l10nhandler', help="Full path to script to handle Localization data")
    parser.add_argument('--retries', default="5", help="Stop Captive Portal after this many failed retries [Default:5]")
    parser.add_argument('--sdm', help="Invoked from sdm", action='store_true')
    #parser.add_argument('--timeout', default="900", help="No activity timeout [Default:900 seconds]")
    parser.add_argument('--web-msgs', help="Replace Web HTML with HTML of your own choosing")
    parser.add_argument('--wlan', default="wlan0", help="Specify WiFi device [Default:wlan0]")
    args = parser.parse_args()
    pd.args = args
    pd.apssid = args.apssid if args.apssid != None else "sdm"
    pd.apip = args.apip if args.apip != None else "10.1.1.1"
    #pd.debug = args.debug
    pd.facname = "sdm" if args.facility == None else args.facility
    pd.apname = f"{pd.facname}0"
    pd.netns = f"tmp-{pd.facname}"
    pd.l10nhandler = "" if args.l10nhandler == None else args.l10nhandler
    pd.sdm = args.sdm
    syslog.openlog(ident="sdm-cportal")
    syslogger("Start Captive Portal Setup")
    if not args.reset:
        if os.path.exists(f"/sys/class/net/{args.wlan}"):
            pd.phydev = read1stline(f"/sys/class/net/{args.wlan}/phy80211/name")
            pd.netdev = args.wlan
        if pd.netdev == "" or pd.phydev == "":
            pxsyslogger(f"? Unrecognized WiFi device {args.wlan}")
    else:
        pd.netdev = args.wlan
    
    pd.retries = getintval(args.retries, '--retries')
    #pd.timeout = getintval(args.timeout, '--timeout')
    pd.dhcp = DHCPClient(pd)
    if args.reset:
        resetnet(pd)
        raise SystemExit(0)
    if not args.defaults is None:
        if not os.path.exists(args.defaults): pxsyslogger(f"? Defaults file '{args.defaults}' not found")
        pd.defaults = read1stline(args.defaults)
        try:
            query_items = parse_qs(urlparse(pd.defaults).query, keep_blank_values=True)
        except ValueError:
            pxsyslogger("? Unable to parse defaults file '{args.defaults}'")
    syslogger("Start Captive Portal")
    pd.pdmsgs = htmsgs()
    pd.leds = LEDflash(pd)
    pd.leds.setsequence(pd.ledseq['APoff'])
    pd.leds.start()
    if args.web_msgs != None:
        msgfn = '.'.join(os.path.basename(args.web_msgs).split('.')[:-1])
        # ** UNTESTED how hard to look for the file? ?? if web_msgs has a path, strip the path, sys.path.append 
        if os.path.exists(args.web_msgs):
            impmsg = __import__(msgfn)
            del pd.pdmsgs
            pd.pdmsgs = impmsg.htmsgs()
    runsts = runserver(pd)
    syslogger("Waiting one second")
    time.sleep(1)
    syslogger("Exit")
    raise SystemExit(runsts)

