#!/bin/bash
#
# This file is sourced by other sdm scripts
#

#
# Common functions 
#
function logit {
    #
    # Writes message to /etc/sdm/history
    #
    # $1="message string"
    #
    [ -f $SDMPT/etc/sdm/history ] && echo "$(thisdate) $1" >> $SDMPT/etc/sdm/history
}

function logtoboth() {
    #
    # Writes the message to the terminal and also to /etc/sdm/history
    #
    # $1="message string" which will be split up across multiple lines if needed
    # $2="nosplit" if lines should not be split up
    #
    local msg="$1"
    local str=() i spc=""
    if [ ${#msg} -le $logwidth -o "$2" == "nosplit" ]
    then
	logit "$msg"
	echo "$msg"
    else
	readarray -t str <<< $(fold -s -w$logwidth <<< $(echo "$msg"))
	for (( i=0 ; i < ${#str[@]} ; i++))
	do
	    logit "${spc}${str[$i]}"
	    echo "${spc}${str[$i]}"
	    spc="  "
	done
    fi	
}

function bootlog() {
    # Write string in $1 to the system log/journal and /etc/sdm/history.log
    logger "FirstBoot: $1"
    logit "> FirstBoot $1"
}

function getpwd() {
    local tmp
    read -s tmp
    echo "$tmp"
}

function changepwd() {
    # Must be in the container (Phase 1 or post-install)
    local user="$1" tpwd="$2" upwd
    if ! getent passwd $user > /dev/null
    then
	logtoboth "% Cannot change password for ${user}; user not found in /etc/passwd"
	return
    fi
    if [ "$tpwd" == "" ]
    then
        echo -n "Password for user '$user': " && read -s upwd
        echo ""
    else
        upwd="$tpwd"
    fi
    chpasswd <<EOF
$user:$upwd
EOF
    [ $showpwd -eq 1 ] && logtoboth "> Set password for user '$user' to '$upwd'" || logtoboth "> Set password for user '$user'"
}

sdm_adduser () {
    # $1: username
    # $2: "" or UID
    # $3: password
    local username=$1 luid=$2 pwd=$3 xuid=""
    [ "$luid" != "" ] && xuid="--uid $luid"
    useradd --create-home --home-dir /home/$username $xuid $username
    usermod --gid users $username
    usermod --groups $groups $username
    changepwd "$username" "$pwd"
    if [ ! -f /etc/sudoers.d/010_$username-nopasswd ]
    then
	logtoboth "> Add user '$username' to sudoers.d"
	echo "$username ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/010_$username-nopasswd
	chmod 440 /etc/sudoers.d/010_$username-nopasswd
    fi
}

function askyn() {
    local ans
    echo -n "$1" '[y/n]? ' ; read $2 ans
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

function outlong () {
    #
    # Write the string in $1 to the file in $2
    # If the line is too long, it will be split up
    #
    local str=() i spc=""
    if [ ${#1} -le 96 ]
    then
	echo "$(date +'%Y-%m-%d %H:%M:%S') $1" >> $2
    else
	readarray -t str <<< $(fold -s -w96 <<< $(echo $1))
	for (( i=0 ; i < ${#str[@]} ; i++))
	do
	    echo "$(date +'%Y-%m-%d %H:%M:%S') ${spc}${str[$i]}" >> $2
	    spc="  "
	done
    fi
}

function logapterror() {
    logtoboth "?!apt returned an error; review /etc/sdm/apt.log"
}

function doapt() {
    #
    # $1 is apt command
    # $2 is $showapt value
    #
    echo "" >> /etc/sdm/apt.log
    outlong "apt $1" "/etc/sdm/apt.log"
    echo "" >> /etc/sdm/apt.log
    if [ "$2" == "1" ]
    then
	DEBIAN_FRONTEND=noninteractive apt-get -qq -o=Dpkg::Use-Pty=0 $1 2>&1 | tee -a /etc/sdm/apt.log
	return $?
    else
	DEBIAN_FRONTEND=noninteractive apt-get -qq -o=Dpkg::Use-Pty=0 $1 >> /etc/sdm/apt.log 2>&1
	return $?
    fi
    return $?
}

function doaptrpterror() {
    #
    # $1 is apt command
    # $2 is $showapt value
    #
    doapt "$1" "$2" || logapterror
}

function ispkginstalled() {
    #
    # $1 has package name
    #
    iver=$(apt-cache policy $1 | grep Installed: 2> /dev/null)
    if [ "$iver" == "" ]
    then
        return 1
    else
        [[ "$iver" =~ "(none)" ]] && return 1 || return 0
    fi
    return
}

function thisdate() {
    echo  "$(date +"$datefmt")"
}

function ord() {
    #
    # Returns the value in decimal of the character in $1
    # e.g. c="a" ; echo $(ord $c) will print 97
    #
    printf '%d' "'$1"
}

function getfsdf() {
    #
    # $1: fs name
    # $2: df component: pcent, avail, etc
    #
    echo $(df --output=$2 $1 | tail -1 | (IFS="%" ; read a ; a="${a% }" ; a="${a# }" echo $a))
}

function logfreespace() {
    #
    # Logs the current free space on $dimg
    #
    local dev="/" extramsg="$1"
    [ "$SDMPT" != "" ] && dev="$SDMPT"
    logtoboth "> $dimgdevname '$dimg' has $(getfsdf $dev avail) 1K-blocks free $extramsg" nosplit
}

function cklogfreespace() {
    #
    # Report if IMG looks full. If not, just log free space
    #
    local dused=$(getfsdf / pcent) extramsg="$1"
    if [ $dused -ge 98 ]
    then
	logtoboth "%%%"
	logtoboth "% $dimgdevname '$dimg' is ${dused}% full ($(getfsdf / avail) 1K-blocks free)" nosplit
	logtoboth "% Review /etc/sdm/apt.log in the image for insufficient disk space errors" nosplit
	logtoboth "% If needed use --extend --xmb nnnn with --customize to create more space" nosplit
	logtoboth "%%%"
    else
	logfreespace "$extramsg"
    fi
}
    
function configitemlog() {
    # $1: Message
    # $2: function to call
    local msg=$1 fn=$2
   if [ "$fn" != "" ]
    then
	if [ "$(type -t "$fn")" == "function" ]
	then
	    [ "$fn" == "logtoboth" ] && msg="> $msg"
	    $fn "$msg"
	else
	    echo "% Unrecognized config item log function: $fn"
	fi
    fi
}

function doconfigitem() {
    #
    # $1: function keyword
    # $2: value
    # $3: "" or "bootlog" (first boot) or "logtoboth" (phase1)
    local rpifun=$1 value=$2 msgfn=$3
    case "$rpifun" in
	# * do_resolution still needs to be sorted out
	serial)
	    configitemlog "Set Serial Port to '$value'" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_serial $value nonint
	    do_raspiconfig do_serial $value nonint
	    ;;
	service-enable)
	    configitemlog "Enable Service '$value'" $msgfn
	    systemctl enable $value
	    ;;
	service-disable)
	    configitemlog "Disable Service '$value'" $msgfn
	    systemctl disable $value
	    ;;
	delayed_boot_behavior)
	    # Processed at the very end of FirstBoot
	    ;;
	boot_behavior|boot_behaviour)  # Allow US spelling as well ;)
	    configitemlog "Set boot_behaviour '$value'" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_boot_behaviour $value nonint
	    do_raspiconfig do_boot_behaviour $value
	    ;;
	powerled)
	    ssys=0
	    (grep -q "\\[actpwr\\]" /sys/class/leds/led0/trigger > /dev/null 2>&1) && ssys=1
	    (grep -q "\\[default-on\\]" /sys/class/leds/led0/trigger > /dev/null 2>&1) && ssys=1
	    if [ $ssys -eq 1 ]
	    then
		configitemlog "Set Power LED to '$value'" $msgfn
		#SUDO_USER=${myuser:-pi} raspi-config do_leds $value nonint
		do_raspiconfig do_leds $value
	    else
		configitemlog "This Pi does not support setting the Power LED; Skipped" $msgfn
	    fi
	    ;;
	audio|pi4video|boot_splash|boot_order|\
	    spi|i2c|boot_wait|net_names|overscan|blanking|\
	    pixdub|overclock|rgpio|camera|onewire)
	    # These are simple on/off and less commonly used so no elaborate logging for them
	    configitemlog "Set $rpifun to '$value'" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_$rpifun $value nonint
	    do_raspiconfig do_$rpifun $value 
	    ;;
	#
	# fstab, keymap, locale, and timezone may be set via sdm --burn command
	#
	# dhcpcd not currently used by sdm, keep for future just in case
	dhcpcd)
	    configitemlog "Append dhcpcd.conf extension '$value' to /etc/dhcpcd.conf" $msgfn
	    cat /etc/sdm/assets/$value >> /etc/dhcpcd.conf
	    ;;
	fstab)
	    configitemlog "Append fstab extension '$value' to /etc/fstab" $msgfn
	    cat /etc/sdm/assets/$value >> /etc/fstab
	    ;;
	keymap)
	    configitemlog "Set Keymap to '$value' (!Ignore invoke-rc.d messages)" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_configure_keyboard "$value" nonint
	    do_raspiconfig do_configure_keyboard "$value"
	    ;;
	locale)
	    configitemlog "Set Locale to '$value'" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_change_locale "$value" nonint
	    do_raspiconfig do_change_locale "$value"
	    declare -x LANG="$value"
	    ;;
	timezone)
	    configitemlog "Set Timezone to '$value'" $msgfn
	    #SUDO_USER=${myuser:-pi} raspi-config do_change_timezone "$value" nonint
	    do_raspiconfig do_change_timezone "$value" 
	    ;;
	*)
	    configitemlog "% Unrecognized option '$rpifun'" $msgfn
	    ;;
    esac

}

function writeconfig() {
    #
    # Write config parameters into the image
    #
    local paramfile="$SDMPT/etc/sdm/cparams"
    rm -f $paramfile
    echo "#Arguments passed from sdm into the IMG on $(date +'%Y-%m-%d %H:%M:%S')" > $paramfile
    for e in version thishost apps xapps appfile xappfile apip apssid aptcache aptdistupgrade autologin \
		     fbatch b0script b1script bootadd bootconfig bootscripts bootsetpairs crond cronhourly \
		     crondaily cronweekly cronmonthly cronsystemd cscript csrc datefmt debugs dhcpcd \
		     dhcpcdwait dimg dimgdev dimgdevname disables domain dtoverlay dtparam ecolors eeprom \
		     expandroot exports fdirtree fgadgetmode fmouse fstab hdmiforcehotplug hdmiignoreedid \
		     hdmigroup hdmimode hostname hotspot journal keymap libfmconf loadlocal locale logwidth \
		     lxdeconflist lxterminalconf modprobe motd groups myuid myuser netman nouser nowaittimesync \
		     os fnopassword passwordpi passwordroot passwordsame passworduser pcmanfmconf pi1bootconf plugindebug plugins poptions \
		     raspiosver rclocal reboot redact regensshkeys frenamepi renamepi noreboot rebootwait redocustomize rootpwd sdfnlogin sdfnnetwork \
		     sdfnresolve sdfnsystem sdfntimesync sdfnuser sdmdir sdmflist showapt showpwd src ssh swapsize svcdisable \
		     svcenable sysctl timezone udev virtmode vncbase vqemu wificountry wpaconf fnowpa custom1 custom2 \
		     custom3 custom4
    do
	echo "$e:\"${!e}\"" >> $paramfile
    done
}

function runoneplugin() {
    #
    # Run the plugin $1 for the phase specified in $2 with args in $3
    # By the time we get here plugin will be in the sdmdir hierarchy
    #
    local p=$(basename $1) phase=$2 pargs="$3" sts=1
    [ "$pargs" != "" ] && argstr="with arguments: '$pargs'" || argstr="with no arguments"
    for d in $SDMPT$sdmdir/local-plugins $SDMPT$sdmdir/plugins
    do
        if [ -f $d/$p ]
	then
	    logtoboth "> Run Plugin '$p' ($d/$p) Phase $phase $argstr"
	    if [ -x $d/$p ]
	    then
		$d/$p "$phase" "$pargs"
		sts=0
		break
	    else
		logtoboth "!!Plugin '$p' file '$d/$p' not executable"
		break
	    fi
	#else
	fi
    done
    [ $sts -eq 1 ] && logtoboth "? Unable to find Plugin '$p'"
}

function runonepluginx() {
    #
    # $1: Plugin name and args (in $plugin format: plugin:key=value:key=value)
    # $2 phase
    #
    local p="$1" pin="${p%:*}" pargs="${p#*:}" phase=$2
    [ "$pargs" == "$p" ] && pargs=""      #Really a null argument list
    runoneplugin $pin $phase "$pargs"
}

function runplugins() {
    #
    # Run the plugins for the phase specified in $1
    #
    local mnt="$SDMPT" phase=$1
    if [ "$plugins" != "" ]
    then
	logtoboth "> Run Plugins Phase '$1'"
	IFS="~" read -a plugs <<< "$plugins"
	for p in "${plugs[@]}"
	do
	    runonepluginx "$p" $phase
	done
    else
	logtoboth "> No Plugins specified with --plugin"
    fi
}

function plugin_getargs() {
    #
    # Handles input data in the form: arg1=val1|arg2=val2|arg3=val3| ...
    # $1: Plugin name
    # $2: Argument list
    # $3: [optional] list of valid keys. Validity not checked if ""
    # $4: [optional] list of required keys. Required keys not checked if ""
    #
    # In addition to creating a key/value symbol for each found key/value,
    # also creates symbol foundkeys="|key1|key2|...|"
    #
    local arglist=() pfx=$1 args="$2" validkeys="$3" rqkeys="$4" keysfound=""
    IFS="|:" read -a arglist <<< "$args"
    for c in "${arglist[@]}"
    do
	# Peel off the args and put them into variables
	while [ "$c" != "" ]
	do
	    IFS="=|:" read key value remain <<< "$c"
	    c="$remain"
	    if [ "$validkeys" != "" ]
	    then
		if ! [[ "$validkeys" =~ "|$key|" ]]
		then
		    logtoboth "%%Plugin $pfx: Unrecognized key '$key' in argument list '$args'"
		fi
	    fi
	    [ "$key" != "" ] && eval "${key}=\"$value\""
	    keysfound="${keysfound}|$key"
	done
    done
    #
    # Check required keys
    #
    if [ "$rqkeys" != "" ]
    then
	# Strip leading "|" from rqkeys to avoid checking for a null first arg
	IFS="|:" read -a arglist <<< "${rqkeys#|}"
	for c in "${arglist[@]}"
	do
	    if ! [[ "${keysfound}|" =~ "|$c|" ]]
	    then
		logtoboth "%%Plugin $pfx: Required key '$c' missing from argument list '$args'"
	    fi
	done
    fi
    # Strip leading "|" to avoid null string on subsequent splitting, but put one on the end
    [ "$keysfound" == "" ] && eval "foundkeys=\"\"" || eval "foundkeys=\"${keysfound#|}|\""
}

function plugin_printkeys() {
    #
    # Print the keys found. plugin_getargs returns the list of found keys in $foundkeys
    # Assumes $pfx:plugin name, $foundkeys:list of keys found, keys set up from plugin_getargs
    #
    if [ "$foundkeys" != "" ]
    then
	logtoboth "> Plugin $pfx: Keys/values found:"
	IFS="|" read -a fargs <<< "$foundkeys"
	for c in "${fargs[@]}"
	do
	    # The construct ${!c} gets the value of the variable 'pointed to' by contents of $c
	    logtoboth "   ${c}: ${!c}"
	done
    fi
}

function plugin_dbgprint() {
    [ $plugindebug -eq 1 ] && logtoboth "D!Plugin $pfx: $1"
}

function iswsl() {
    #
    # Return true if running system is a WSL instance
    #
    local uname=$(uname -a)
    [[ "${uname,,}" =~ "microsoft" ]] && return 0 || return 1
}

function initvirt() {
    # Check IMG and running system. If running on 32-bit and IMG is 64-bit, prepare for chroot
    # wtf -> what's the file :)
    # wami -> what is my OS (that sdm running on)
    # $1 = function to call to write msgs, or null to echo
    local msgrtn=$1
    [ "$msgrtn" == "" ] && msgrtn=echo
    vqemu=""
    bfs=""
    wami=$(file /bin/ls)
    wtf=$(file $SDMPT/bin/ls)
    IFS="," read wtfelf wtfarch rest <<< "$wtf"
    [[ "$wtfarch" =~ "ARM" ]] || errexit "? Unrecognized architecture '$wtfarch' in IMG"
    if [[ "$wami" =~ "ARM" ]]
    then
	if [[ "$wami" =~ "32-bit" ]]
	then
	    if  [[ "$wtf" =~ "aarch64" ]]
	    then
		$msgrtn "% Configure chroot to operate on this 64-bit IMG on your 32-bit ARM OS"
		$msgrtn "  * sdm will run more slowly due to qemu emulation"
		virtmode="chroot"
		vqemu="aarch64"
		qf="/usr/bin/qemu-aarch64-static"
		bfs=":qemu-aarch64:M:0:\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:$qf:"
	    fi
	fi
    else
	# sdm not running sdm on ARM
	IFS="," read wamielf wamiarch rest <<< "$wami"
	$msgrtn "% Configure chroot for sdm on your '${wamiarch##\ }' computer"
	$msgrtn "  * sdm will run more slowly due to qemu emulation"
	virtmode="chroot"
	[[ "$wtf" =~ "32-bit" ]] && vqemu="arm" || vqemu="aarch64"
    fi
}

function chroot_cleanup() {
    if [ "$SDMPT" != "" ]
    then
	[ "$qemu" != "" ] && rm -f $SDMPT/usr/bin/$qemu
	umount $SDMPT/{dev/pts,dev,proc,sys}
    else
	logtoboth "%% SDMPT null in handling chroot cleanup. Please log an issue at https://github.com/gitbls/sdm; Continuing..."
    fi
}

function ctrlchroot() {
    echo "% Caught CTRL/C in chroot; Cleaning up..."
    declare -x SDMPT="$OLDSDMPT"
    declare -x SDMNSPAWN="$OLDSDMNSPAWN"
    chroot_cleanup
    exit 1
}

function sdm_spawn() {
    #
    # $1 - command
    # $2 - nspawn switches
    # $3 - setting for SDMNSPAWN
    # Already mounted on $SDMPT
    # SDMPT redefined to be "" during Phase 1 nspawn/chroot. [[ -z "${SDMPT+z}" ]] test will work since it is defined
    #
    local cmd="$1" nspawnsw="$2" nsp="$3"
    if [[ "$virtmode" =~ "nspawn" ]]
    then
	[ -t 0 ] && cmode="--console interactive" || cmode="--console pipe"
	read s vers junk <<< $(systemctl --version)
	[[ "$vers" -lt "242" ]] && cmode=""
	nspawnsw="$nspawnsw --setenv=SDMNSPAWN=$nsp"
	systemd-nspawn -q --directory=$SDMPT --setenv=SDMPT="" $nspawnsw $cmode $cmd
    else
	#
	# Copy appropriate qemu-${chroot}-static into the IMG
	# $bfs and $vqemu set in initvirt
	#
	qemu=""
	if [ "$vqemu" != "" ]
	then
	    [ ! -f /usr/bin/qemu-${vqemu}-static ] && errexit "? qemu-${vqemu}-static missing for chroot; try 'sudo apt install qemu-user-static binfmt-support'"
	    if [ ! -f /proc/sys/fs/binfmt_misc/qemu-${vqemu} ]
	    then
		ubf=""
		for fn in /sbin/update-binfmts /usr/sbin/update-binfmts
		do
		    [ -f $fn ] && ubf=$fn && break
		done
		[ ! $? ] && errexit "? Cannot find update-binfmts; try 'sudo apt install binfmt-support'"
		logtoboth "%% Run 'update-binfmts --enable' to enable chroot"
		$ubf --enable
		if [ "$bfs" != "" -a ! -f /proc/sys/fs/binfmt_misc/qemu-${vqemu} ]
		then
		    echo "% Add binfmt for 64-bit ARM (aarch64)"
		    echo "$bfs" > /proc/sys/fs/binfmt_misc/register
		fi
		[ -f /proc/sys/fs/binfmt_misc/qemu-${vqemu} -o -x /bin/qemu-${vqemu}-static ] || errexit "? Cannot find binfmt for architecture '${vqemu}'"
	    fi
	    qemu="/usr/bin/qemu-${vqemu}-static"
	fi
	[ "$qemu" != "" ] && cp $qemu $SDMPT/usr/bin
	declare -x OLDSDMPT="$SDMPT"
	declare -x OLDSDMNSPAWN="$SDMNSPAWN"
	trap "ctrlchroot" SIGINT
	for fs in dev dev/pts proc sys ; do mount --bind /$fs $SDMPT/$fs ; done
	declare -x SDMPT=""
	declare -x SDMNSPAWN="$nsp"
	chroot $OLDSDMPT $qemu /bin/bash $cmd
	declare -x SDMPT="$OLDSDMPT"
	declare -x SDMNSPAWN="$OLDSDMNSPAWN"
	trap SIGINT
	chroot_cleanup
    fi
    return
}

function getconfbool() {
    #
    # Grab one entry (name in $1) from cparams safely
    #
    local mnt="$SDMPT" pname="$1"
    paramfile="/etc/sdm/cparams"
    if [ -f $paramfile ]
    then
        pval=$((grep ${pname}: $paramfile) | (IFS=":" read kn kv ; echo $kv))
    else
        pval=0
    fi
    # del enclosing quotes on value read from cparams
    pval="${pval#\"}"
    pval="${pval%\"}"
    cmval=${!pname}
    rval=$((pval|cmval))
    echo "$rval"
}

function getconfstr() {
    #
    # Grab one entry string (name in $1) from cparams safely
    #
    local mnt="$SDMPT" pname="$1"
    paramfile="/etc/sdm/cparams"
    if [ -f $paramfile ]
    then
        pval=$((grep ${pname}: $paramfile) | (IFS=":" read kn kv ; echo $kv))
    else
        pval=0
    fi
    cmval=${!pname}
    [ "$cmval" != "" ] && rval=$cmval || rval=$pval
    echo "$rval"
}

function setbootset() {
    #
    # Handle --bootset, --svcdisable and --svcenable for customize and burn commands
    # Can be called from Burn (SDMNSPAWN=~Burn) or Phase1
    # Changes are always written to auto-1piboot
    #
    local mnt="$SDMPT"
    local citems=() c key value
    if [ "$bootsetpairs" != "" ]
    then
	IFS="," read -a citems <<< "$bootsetpairs"
	for c in "${citems[@]}"
	do
	    IFS=":=" read key value <<< "$c"
	    [ "$value" == "" ] && value=0
	    # Remove any old entry for this key and write the new one
	    if ! grep "$key=$value" $mnt/etc/sdm/auto-1piboot.conf > /dev/null 2>&1
	    then
		logtoboth "> Set --bootset ${key} ${value}"
		sed -i "/^$key=/d" $mnt/etc/sdm/auto-1piboot.conf
		echo "$key=$value" >> $mnt/etc/sdm/auto-1piboot.conf
	    fi
	done
    fi
    if [ "$svcdisable" != "" ]
    then
	IFS="," read -a citems <<< "$svcdisable"
	for c in "${citems[@]}"
	do
	    sed -i "/^service-enable=$c/d" $mnt/etc/sdm/auto-1piboot.conf   #Delete enables of this service
	    if ! grep "service-disable=$c" $mnt/etc/sdm/auto-1piboot.conf > /dev/null 2>&1
	    then
		logtoboth "> Disable service '$c'"
		echo "service-disable=$c" >> $mnt/etc/sdm/auto-1piboot.conf
	    fi
	done
    fi
    if [ "$svcenable" != "" ]
    then
	IFS="," read -a citems <<< "$svcenable"
	for c in "${citems[@]}"
	do
	    sed -i "/^service-disable=$c/d" $mnt/etc/sdm/auto-1piboot.conf  #Delete disables of this service
	    if ! grep "service-enable=$c" $mnt/etc/sdm/auto-1piboot.conf > /dev/null 2>&1
	    then
		logtoboth "> Enable service '$c'"
		echo "service-enable=$c" >> $mnt/etc/sdm/auto-1piboot.conf
	    fi
	done
    fi

}

function do_raspiconfig() {
    #
    # $1=command
    # $2=value
    local cmd=$1 value=$2
    if type -P raspi-config > /dev/null
    then
	SUDO_USER=${myuser:-pi} raspi-config $cmd "$value" nonint # prefer to not block outputs! > /dev/null 2>&1
    else
	logtoboth ">!Unable to find raspi-config for function '$cmd' with value '$value'"
    fi
}

function copyifnewer() {
    # Copy $1 to $2 if $1 is newer
    # Target must have same basename as src (no rename as part of copy)
    # Target can be a directory or a dir/$(basename $1)
    # Return true if it's newer (did copy) false if not
    local src=$1 dst=$2
    local fn=$(basename $src)
    [ "$fn" != "$(basename $dst)" ] && dst="$dst/$fn"
    if [ -f "$dst" ]
    then
	[ "$1" -nt "$dst" ] || return 1
    fi
    cp $1 $2
    return 0
}

function checkifnewer() {
    # Checks $1 and $2 to see if $1 is newer
    # Target must have same basename as src (no rename as part of the check)
    # Target can be a directory or a dir/$(basename $1)
    # Return true if $1 newer, false if not
    local src=$1 dst=$2
    local fn=$(basename $src)
    [ "$fn" != "$(basename $dst)" ] && dst="$dst/$fn"
    if [ -f "$dst" ]
    then
	[ "$1" -nt "$dst" ] && return 0 || return 1
    fi
    return 0  # Doesn't exist, so $1 is newer
}

function getfinalbbh {
    #
    # Get boot_behaviour from auto-1piboot if provided
    # If not, return $1
    #
    aval=$((grep ^boot_behav /etc/sdm/auto-1piboot.conf) | (IFS=":=" read kn kv ; echo $kv))
    [ "$aval" == "" ] && echo "$1" || echo "$aval"
}

function setlightdmautologin() {
    #
    # $1 = "burning" if called from burn. "" otherwise
    #
    local burn="$1"
    [ $autologin -eq 1 ] && bbh="B4" || bbh="B3"
    if [ "$burn" != "" ]
    then
	sed -i "/^delayed_boot_behavior=.*/d" /etc/sdm/auto-1piboot.conf
	logtoboth ">%Desktop Autologin setting '$bbh' will set be after First Boot"
	echo "delayed_boot_behavior=$bbh" >> /etc/sdm/auto-1piboot.conf
	do_raspiconfig do_boot_behaviour B1
    else
	logtoboth ">%Desktop Autologin set to '$bbh'"
	do_raspiconfig do_boot_behaviour $bbh
    fi
}

function delaylightdmenable() {
    #
    # $1 = "burning" if called from burn. "" otherwise
    #
    local burn="$1"
    logtoboth "> Set RasPiOS Full to 'console no login' for First Boot"
    #SUDO_USER="$userx" raspi-config do_boot_behaviour B1 nonint > /dev/null 2>&1
    do_raspiconfig do_boot_behaviour B1
    systemctl set-default multi-user.target
    if [ "$burn" != "" ]
    then
	sed -i "/^delayed_boot_behavior=.*/d" /etc/sdm/auto-1piboot.conf
	[ $autologin -eq 1 ] && bbh="B4" || bbh="B3"
	logtoboth ">%Desktop Autologin setting '$bbh' will be set after First Boot"
	echo "delayed_boot_behavior=$bbh" >> /etc/sdm/auto-1piboot.conf
    else
	if (grep '^boot_behav' /etc/sdm/1piboot.conf > /dev/null 2>&1) || (grep '^boot_behav' /etc/sdm/auto-1piboot.conf > /dev/null 2>&1)
	then
	    aval="$(getfinalbbh B1)"
	    logtoboth ">%1piboot.conf|auto-1piboot.conf 'boot_behaviour' setting $aval will be honored after First Boot"
	else
	    [ $autologin -eq 1 ] && bbh="B4" || bbh="B3"
	    logtoboth ">%Desktop Autologin setting '$bbh' will be re-enabled after First Boot"
	    echo "delayed_boot_behavior=$bbh" >> /etc/sdm/auto-1piboot.conf
	fi
    fi
}

function do_disables() {
    # Process disables
    # $1 has list of requested disables separated by "|" if more than one item
    local dbls="$1|"
    IFS="|" read -a dlist <<< "$dbls"
    for ditem in "${dlist[@]}"
    do
	case "$ditem" in
	    bluetooth)
		fndis="/etc/sdm/0piboot/050-disable-bt.sh"
		if [ -f $fndis ]
		then
		    logtoboth "% Bluetooth already disabled"
		else
		    logtoboth "> Set Bluetooth to disable in FirstBoot per --disable bluetooth"
		    cat > $fndis <<EOF
#!/bin/bash
blfile="blacklist-sdm-bluetooth.conf"
logger "FirstBoot Disable bluetooth using /etc/modprobe.d/\$blfile"
printf "blacklist btbcm\nblacklist hci_uart\n" > /etc/modprobe.d/\$blfile
systemctl disable hciuart
EOF
		    chmod 755 $fndis
		fi
		;;
	    piwiz)
		logtoboth "> Disable running piwiz and userconfig on first boot per --disable piwiz"
		[ -f /etc/xdg/autostart/piwiz.desktop ] && mv /etc/xdg/autostart/piwiz.desktop /etc/xdg/autostart/.piwiz.desktop.sdm
		systemctl disable userconfig.service > /dev/null 2>&1
		systemctl mask    userconfig.service > /dev/null 2>&1
		getent passwd rpi-first-boot-wizard > /dev/null && userdel -r rpi-first-boot-wizard > /dev/null 2>&1
		rm -f /etc/sudoers.d/010_wiz-nopasswd
		rm -f /etc/xdg/autostart/deluser.desktop
		;;
	    swap)
		logtoboth "> Disable swapfile per --disable swap"
		systemctl disable dphys-swapfile
		# Don't need to change CONF_SWAPSIZE if dphys-swapfile service is disabled
		#    sed -i "s/CONF_SWAPSIZE=.*/CONF_SWAPSIZE=0/" /etc/dphys-swapfile
		;;
	    triggerhappy)
		logtoboth "> Disable triggerhappy service per --disable triggerhappy"
		systemctl disable triggerhappy.service
		systemctl disable triggerhappy.socket
		#Eliminate thd.socket errors from udev
		[ -f /lib/udev/rules.d/60-triggerhappy.rules ] && mv /lib/udev/rules.d/60-triggerhappy.rules /lib/udev/rules.d/.60-triggerhappy-sdm.rules
		[ -f /usr/sbin/thd ] && mv /usr/sbin/thd /usr/sbin/thd.sdm
		;;
	    wifi)
		fndis="/etc/sdm/0piboot/055-disable-wifi.sh"
		if [ -f $fndis ]
		then
		    logtoboth "% WiFi already disabled"
		else
		    logtoboth "> Set WiFi to disable in FirstBoot per --disable wifi"
		    cat > $fndis <<EOF
#!/bin/bash
blfile="blacklist-sdm-wifi.conf"
logger "FirstBoot Disable wlan0 using /etc/modprobe.d/\$blfile"
printf "blacklist brcmfmac\nblacklist brcmutil\n" > /etc/modprobe.d/\$blfile
EOF
		    chmod 755 $fndis
		fi
		;;
	esac
    done
}

function gterm1() {
    #
    # $1: control (10:foreground, 11:background, 12:cursor, 13:mousefg, 14:mousebg)
    # $2 varname to set
    #
    local vname="$2" cval
    # Query the xterm for the attribute and read result
    echo -e -n "\e]$1;?\a"
    read -s  -N 40 -t 0.1 cval
    # Trim response to just the color string and return it in the named variable
    cval="${cval:2:${#cval}-3}"   # Strip off ESC] at beginning and ctrl-g at end of string
    cval="${cval##*;}"            # Strip off leading semi-colon
    printf -v "$vname" "%s" "$cval" #eval "${vname}=\"$cval\""     # Define a variable for the value
}

function gtermcolors() {
    #
    # Query the xterm for the current terminal colors (cursor, bg, fg)
    # Return in the value named in ${1}cursor ${1}bg ${1}fg (rgb:xxxx/xxxx/xxxx)
    #
    gterm1 10 "${1}fg"
    gterm1 11 "${1}bg"
    gterm1 12 "${1}cursor"
}

function stermcolors() {
    #
    # Arguments are positional, but optional. e.g., "" "" "00" will set only the cursor
    # $1 - foreground
    # $2 - background
    # $3 - cursor
    # $4 - (optional) name of string for saving current colors (see gtermcolors)
    #
    local os=""
    [ "$4" != "" ] && gtermcolors "$4"
    [ "$1" != "" ] && os="\e]10;$1\a"
    [ "$2" != "" ] && os="${os}\e]11;$2\a"
    [ "$3" != "" ] && os="${os}\e]12;$3\a"
    printf "$os"
}

function resetcolors() {
    #
    # Set all colors saved from stermcolors
    #
    local tfg tbg tcursor
    # old way: eval "tfg=\$${1}fg ; tbg=\$${1}bg ; tcursor=\$${1}cursor"
    tfgn="${1}fg" ; tbgn="${1}bg" ; tcn="${1}cursor" 
    printf -v tfg "%s" "${!tfgn}" 
    printf -v tbg "%s" "${!tbgn}"
    printf -v tcursor "%s" "${!tcn}"
    stermcolors "$tfg" "$tbg" "$tcursor"
}

function flashled0() {
    echo 1 | tee /sys/class/leds/led0/brightness > /dev/null 2>&1
    sleep $1
    echo 0 | tee /sys/class/leds/led0/brightness > /dev/null 2>&1
    sleep .2
}

function morseled() {
    local msg="$1"
    local dit=".2" dot=".6" inter=".5"
    for (( i=0 ; i<${#msg} ; i++))
    do
	case "${msg:$i:1}" in
	    .) flashled0 $dit ;;
	    -) flashled0 $dot ;;
	    " ") sleep $inter ;;
	esac
	
    done
}

function iponline() {
    #
    # Test if IP address $1 is online
    # Returns 0 if online, 1 if offline
    #
    local pcnt=1 pingwait=1
    if (ping -c $pcnt -W $pingwait $1 > /dev/null 2>&1 )
    then
	return 0
    else
	return 1
    fi
}

function ckkeymap() {
    [ "$1" == "" ] && return 0
    (grep "^  ${1} " /usr/share/doc/keyboard-configuration/xorg.lst > /dev/null 2>&1) && return 0 || return 1
}

function cklocale() {
    [ "$1" == "" ] && return 0
    (grep "^${1}" /usr/share/i18n/SUPPORTED > /dev/null 2>&1) && return 0 || return 1
    return 0
}

function ckwificountry() {
    [ "$1" == "" ] && return 0
    (grep "^${1}" /usr/share/zoneinfo/iso3166.tab > /dev/null 2>&1) && return 0 || return 1
}

function cktimezone() {
    [ "$1" == "" ] && return 0
    [ -e /usr/share/zoneinfo/$1 ] && return 0 || return 1
}
